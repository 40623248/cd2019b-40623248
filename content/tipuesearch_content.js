var tipuesearch = {"pages": [{'title': 'Onshape 協同繪製', 'text': '', 'tags': '', 'url': 'Onshape 協同繪製.html'}, {'title': '手足球台設計', 'text': 'Onshape \n \n 參考了老師的提供的影片，模仿他麼]們的做法畫出了這個足球台，參考影片是以木材去製作，所以我的零件都是以一片一片去繪製，組合在一起。 \n \n \n 參考影片: \n \n 參考資料: \n https://iliketomakestuff.com/product/foosball-table/ \n', 'tags': '', 'url': '手足球台設計.html'}, {'title': '送球機構設計', 'text': 'onshape動畫 :\xa0onshape\xa0 Link \n vrep \n \n 設計: \n 利用pyslvs模擬機構運行路徑 \n \n 利用onshape 將機構繪出，並繪製出抬球機構 \n \n \n PS: 剛開始在畫的時候，要抓到球的位置並不容易，於是參考老師的影片，將第二個抬球的零件改為撥桿，比要容易就能將球運上去。 \n onshape繪製影片 \n \n', 'tags': '', 'url': '送球機構設計.html'}, {'title': 'V-rep 夾娃娃機', 'text': 'onshape \n Clip doll machine.ttt \n \n 組裝好X、Y、Z、跟夾爪的軸，限制了軸的移動距離。 \n ---- \n \n \n \n 嘗試裝球體的軸 ( Spherical joints ) ，但是晃動得太嚴重，還會自轉，所以就先不裝了。 \n 後來把球體的軸改成 水平 跟 垂直 軸，讓他不會自轉，但還是會晃，感覺比較真實，在重量上做了很多的調整，才讓他看起來比較正常。(忘了錄影QQ) \n ------------------------------------------------------------------------------------------------------- \n 之後想讓夾娃娃機比較像外面的，就想讓他在抓起來的時候，回到原點並把爪子張開，將物體放下，於是我加了以下的程式。 \n ---return\n    result=sim.readProximitySensor(Sensor)\n    if (result>0) then A=sim.getSimulationTime() end\n    if (A > 0) then\n        sliding_3 = sliding_3 +0.01\n        if (sliding_3 >= 0) then sliding_x = sliding_x -0.01 end\n        if (sliding_x <= -1.1) then sliding_2 = sliding_2 +0.01 end\n        if (sliding_2 >= 1.3) then sliding_4 = -1 end\n    end\n    if (sliding_4 <= -0.02) then A=-1 end\n--- \n 解釋: 在爪子內放一個球柱的感測器，感測到夾子夾起來，Z軸先上升到頂點，換X軸移動到指定的位子，再換Y軸移動到原點，最後將爪子鬆開。 \n 程式最後一行是要讓 A 返回到 小於0 ， 不然就會無法控制其他軸。 \n \n 功能展示 1 \n \n \n 功能展示 2 (成功夾取物品) \n ------------------------------------------------------------------------------------------------------- \n function sysCall_init()\nsliding_x = -1.1\nsliding_2 = 1.3\nsliding_3 = 0\nsliding_4 = -0.04\n\nA = 0\n\nSensor=sim.getObjectHandle("sensor")\nX = sim.getObjectHandle(\'x_slider\')\nY = sim.getObjectHandle(\'y_slider\')\nZ = sim.getObjectHandle(\'z_slider\')\nC = sim.getObjectHandle(\'catch_slider\')\n\nend\n\n\nfunction sysCall_actuation()\nsim.setJointTargetPosition(X,sliding_x)\nsim.setJointTargetPosition(Y,sliding_2)\nsim.setJointTargetPosition(Z,sliding_3)\nsim.setJointTargetPosition(C,sliding_4)\n---return\n    result=sim.readProximitySensor(Sensor)\n    if (result>0) then A=sim.getSimulationTime() end\n    if (A > 0) then\n        sliding_3 = sliding_3 +0.01\n        if (sliding_3 >= 0) then sliding_x = sliding_x -0.01 end\n        if (sliding_x <= -1.1) then sliding_2 = sliding_2 +0.01 end\n        if (sliding_2 >= 1.3) then sliding_4 = -1 end\n    end\n    if (sliding_4 <= -0.02) then A=-1 end\n---\nmessage,auxiliaryData=sim.getSimulatorMessage()\n        while message ~= -1 do\nkey=auxiliaryData[1]\nsim.addStatusbarMessage(\'key:\'..key)\n            if (message==sim.message_keypress) then\n--X_axis\n\n                if (auxiliaryData[1]==100) then --a\n                        -- \n                    if (sliding_x >= 1.2) then \n                    else sliding_x = sliding_x + 0.02\n                    end\n                end\n                    \n                if (auxiliaryData[1]==97) then --d\n                        -- \n                    if (sliding_x <= -1.2) then \n                    else sliding_x = sliding_x - 0.02\n                    end\n                end\n    ---axis y\n                if (auxiliaryData[1]==115) then --w\n                        -- \n                    if (sliding_2 >= 1.4) then \n                    else sliding_2 = sliding_2 + 0.02\n                    end\n                end\n                if (auxiliaryData[1]==119) then --s\n                        -- \n                    if (sliding_2 <= -1.4) then \n                    else sliding_2 = sliding_2 - 0.02\n                    end\n                end\n    ---axis z\n                if (auxiliaryData[1]==2007) then --up\n                    if (sliding_3 >= 0.1) then \n                    else sliding_3 = sliding_3 + 0.05\n                    end\n                end\n                if (auxiliaryData[1]==2008) then --down\n                    if (sliding_3 <= -0.85) then \n                    else sliding_3 = sliding_3 - 0.05\n                    end\n                end\n    ---catch\n                if (auxiliaryData[1]==32) then --space\n                    sliding_4 = 1\n                end\n            end\nmessage,auxiliaryData=sim.getSimulatorMessage()\n        end\nend\n \n', 'tags': '', 'url': 'V-rep 夾娃娃機.html'}, {'title': 'V-rep 動態模擬', 'text': '', 'tags': '', 'url': 'V-rep 動態模擬.html'}, {'title': '送球機構模擬', 'text': 'Vrep模擬 : \xa0   vrep檔案 \n 加裝sensor : 當 球來的時候 ，機構才開使運行。 \n \n \n 將抬球機構與球桌合併 \n \n \n 以下為連桿機構相參考資料： \n \n', 'tags': '', 'url': '送球機構模擬.html'}, {'title': 'V-rep 程式', 'text': '', 'tags': '', 'url': 'V-rep 程式.html'}, {'title': '送球機構', 'text': '\n \n function sysCall_init()\n    joint=sim.getObjectHandle(\'drive_1\')\n    Sensor2=sim.getObjectHandle("1_sensor_1")\n    Sensor=sim.getObjectHandle("1_sensor_2")\n    speed=0\n    A=-1\n    B=-1\n    i=0\n    p=0\nend\n\nfunction sysCall_actuation()\n    result=sim.readProximitySensor(Sensor2)\n    if (result>0) then A=sim.getSimulationTime()+4.6 end\n    if (A<sim.getSimulationTime()) then\n        sim.setJointTargetVelocity(joint,speed)\n    else\n        sim.setJointTargetVelocity(joint,speed-1)\n    end\n    k=sim.readProximitySensor(Sensor)\n    if (k>0) then \n        p=p+0.1\n    else\n        p=0\n    end\n    if (p>3) then p=0 end\n    if (p>2.9) then\n        i=i+1\nsim.addStatusbarMessage(\'team A point:\'..i)\n    end\n        \n\nend\n \n \n', 'tags': '', 'url': '送球機構.html'}, {'title': '人對人', 'text': '\n \n \n threadFunction=function()\n    while sim.getSimulationState()~=sim.simulation_advancing_abouttostop do\n        -- Read the keyboard messages (make sure the focus is on the main window, scene view):\n        message,auxiliaryData=sim.getSimulatorMessage()\n        while message~=-1 do\n            if (message==sim.message_keypress) then\n                if (auxiliaryData[1]==119) then\n                    -- up key\n                    velocity=100\n                    torque=200\n                    hammer_back = 0\n                end\n                if (auxiliaryData[1]==115) then\n                    -- down key\n                     hammer_back = 1\n                     torque=-200\n                     velocity = -100\n                end\n                if (auxiliaryData[1]==97) then\n                    -- right key\n                     sliding = sliding + 0.005\n                     sliding_1 = sliding_1 + 0.005  \n                end\n                if (auxiliaryData[1]==100) then\n                    -- left key\n                     sliding = sliding - 0.005\n                     sliding_1 = sliding_1 - 0.005\n                end\n                if (sliding < -0.0445) then\n                    sliding = -0.0445\n                elseif (sliding > 0.0445) then\n                    sliding = 0.0445\n                end\n                if (sliding_1 < -0.08255) then\n                    sliding_1 = -0.08255\n                elseif (sliding_1 > 0.08255) then\n                    sliding_1 = 0.08255\n                end\n            end\n            message,auxiliaryData=sim.getSimulatorMessage()\n        end\n \n        -- We take care of setting the desired hammer position:\n        if hammer_back == 1\n            then \n               sim.setJointPosition(joint, -1, orientation)\n               sim.setJointPosition(joint_1, -1, orientation)\n               --sim.setObjectPosition(hammer, -1, position)\n        end\n        sim.setJointTargetPosition(joint, velocity)\n        sim.setJointTargetPosition(joint_1, velocity)\n        --sim.setJointForce(joint,torque)\n        sim.setJointTargetPosition(slider, sliding)\n        sim.setJointTargetPosition(slider_1, sliding_1)\n\n        -- Since this script is threaded, don\'t waste time here:\n        sim.switchThread() -- Resume the script at next simulation loop start\n    end\nend\n-- Put some initialization code here:\n-- Retrieving of some handles and setting of some initial values:\njoint=sim.getObjectHandle(\'A1_1_joint\')\nhammer=sim.getObjectHandle(\'A1_1_player\')\nslider=sim.getObjectHandle("A1_1_slider")\njoint_1=sim.getObjectHandle(\'A1_2_joint\')\nhammer_1=sim.getObjectHandle(\'A1_2_player\')\nslider_1=sim.getObjectHandle("A1_2_slider")\nvelocity=0\nhammer_back=0\ntorque=0\nsliding = 0\nsliding_1 = 0\norientation=sim.getJointPosition(joint, -1)\nposition=sim.getObjectPosition(hammer, -1)\nslider_position=sim.getJointPosition(slider, -1)\n-- Here we execute the regular thread code:\nres,err=xpcall(threadFunction,function(err) return debug.traceback(err) end)\nif not res then\n    sim.addStatusbarMessage(\'Lua runtime error: \'..err)\nend \n \n', 'tags': '', 'url': '人對人.html'}, {'title': '系統功能展示', 'text': '\n 新增了2個vision sensor，當成玩家視角，使對打更加順利。 \n \n \n', 'tags': '', 'url': '系統功能展示.html'}, {'title': '期末報告', 'text': '40623248 廖柏誠結案口頭簡報 \n \n 評分比例： \n 學員出席 (20%)： \n 20% \n Github 倉儲管理\xa0 (20%)： \n 10% \n Onshape 協同操作 (20%)： \n 18 % \n V-rep 模擬 (20%)： \n 18 % \n 程式開發 (20%)： \n 10 % \n 總分：76 \n', 'tags': '', 'url': '期末報告.html'}]};